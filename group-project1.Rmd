---
title: "group_project1"
author: "Annabelle Frin"
date: "17/11/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r}
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(rgdal)
library(sp)
library(maptools)
library("rgdal")
library("lattice")
library(geosphere)

largeur_cellule <- 200

```


```{r}
#train <- read.csv("train.csv", sep = ",")
#test <- read.csv("data/test.csv", sep = ",")
#head(train)
test=train_000
test <- read.csv("train-000.csv", sep = ",")
#head(train)
summary(test)
cleaning <- function(train) {
  train_df <- train %>% filter(fare_amount >=0) %>% filter(pickup_longitude > -100, pickup_longitude < -50, pickup_latitude > 20, pickup_latitude < 60, dropoff_longitude > -100, dropoff_longitude < -50, dropoff_latitude > 20, dropoff_latitude < 60)
  return(train_df)
}
test <- cleaning(test)
```

```{r}



shpurl <- "https://www1.nyc.gov/assets/planning/download/zip/data-maps/open-data/nybb_13a.zip"

tmp    <- tempfile(fileext=".zip")
download.file(shpurl, destfile=tmp)
files <- unzip(tmp, exdir=getwd())



# Load & plot shapefile
shp <- readShapePoly(files[grep(".shp$", files)])

# Load & plot shapefile
shp <- readShapePoly(files[grep(".shp$", files)])
### read shapefile
shp <- readOGR("nybb_13a", "nybb")
proj4string(shp) 

cord.dec = SpatialPoints(cbind(test$pickup_longitude, test$pickup_latitude), proj4string = CRS("+proj=longlat"))


cord.UTM <- spTransform(cord.dec, CRS(proj4string(shp)))
cord.UTM

cord <- data.frame(cord.UTM@coords, id="A", stringsAsFactors=F)

cord2 <- cord

shpurl <- "https://www1.nyc.gov/assets/planning/download/zip/data-maps/open-data/nybb_13a.zip"
tmp    <- tempfile(fileext=".zip")
download.file(shpurl, destfile=tmp)
files <- unzip(tmp, exdir=getwd())



coordinates(cord) <- ~ coords.x1 + coords.x2
proj4string(cord) <- proj4string(shp)

cord@coords

### SpatialGrid object
bb <- bbox(shp)

cellsize <- c(3.28084, 3.28084)*largeur_cellule  # cell size 1000m

                                # 1 ft = 3.28084 m
cc <- bb[, 1] + (cellsize/2)  # cell offset
cd <- ceiling(diff(t(bb))/cellsize)  # number of cells per direction
grd <- GridTopology(cellcentre.offset=cc, cellsize=cellsize, cells.dim=cd)

spatial_grid <- SpatialGridDataFrame(grd,
                               data=data.frame(id=1:prod(cd)),
                               proj4string=CRS(proj4string(shp)))   

spplot(spatial_grid, "id",
       panel = function(...) {
         panel.gridplot(..., border="black")
         sp.polygons(shp)
         #panel.text(...)


       })
over(cord, spatial_grid)
summary(over(cord, spatial_grid))





# Plot coordinates
plot(shp)
points(cord2$coords.x1, cord2$coords.x2, pch=19, col="red")
```

```{r}
# Permet de calculer l'idea pour chaque point 

over_2 <- function (long, lat, grid) {
  cord.dec = SpatialPoints(cbind(long, lat), proj4string = CRS("+proj=longlat"))
  cord.UTM <- spTransform(cord.dec, CRS(proj4string(shp)))
  cord <- data.frame(cord.UTM@coords, id="A", stringsAsFactors=F)
  cord2 <- cord
  coordinates(cord) <- ~ long + lat
  proj4string(cord) <- proj4string(shp)

  return(over(cord,grid))
}


```


```{r}


#VERSION 2 - En utilisant la sortie de la fonction de VIGGIANO suivante :


transformation <- function (list,grid){
  
  #We want to clean the data in order to use it efficiently late. 
  
  #Calling the variables
  key <- as.character(list[3])
  price <- as.numeric(list[2])
  long1 <- as.numeric(list[4])
  lat1 <- as.numeric(list[5])
  long2 <-as.numeric( list[6])
  lat2 <- as.numeric(list[7])
  passenger <- as.numeric(list[8])
  

  #Retrieving the day and the hour
  day <- as.numeric(substr(key,9,10))
  hour <- as.numeric(substr(key,12,13))
  
  
  #Transforming the coords in UTM
  cord.dec_1 = SpatialPoints(cbind(long1, lat1), proj4string = CRS("+proj=longlat"))
  cord.UTM_1 <- spTransform(cord.dec_1, CRS(proj4string(shp)))
  cord_1 <- data.frame(cord.UTM_1@coords, stringsAsFactors=F)
  cord_1_a <- data.frame(cord.UTM_1@coords, id="A", stringsAsFactors=F)
  coordinates(cord_1_a) <- ~ long1 + lat1
  proj4string(cord_1_a) <- proj4string(shp)
  
  cord.dec_2 = SpatialPoints(cbind(long2, lat2), proj4string = CRS("+proj=longlat"))
  cord.UTM_2 <- spTransform(cord.dec_2, CRS(proj4string(shp)))
  cord_2 <- data.frame(cord.UTM_2@coords, stringsAsFactors=F)
  cord_2_a <- data.frame(cord.UTM_2@coords, id="A", stringsAsFactors=F)
  coordinates(cord_2_a) <- ~ long2 + lat2
  proj4string(cord_2_a) <- proj4string(shp)
  
  
  #Getting the id of the different squares
  idp <- over(cord_1_a,grid)
  idd <- over(cord_2_a,grid)
  
  
 
  return(c(#cord_1[1],cord_1[2],cord_2[1],cord_2[2], #if we also want the UTM coords

    
    long1,lat1,long2,lat2,
    
    idp,idd,day,hour,price,passenger))
  
  
  
}

```

```{r}


#Fonction qui donne le dataset final mais que pour un trajet initial (de A à B) 
path <- function(pretty_row) {
  pretty_row <- test_row
  coordA <- c(pretty_row[[1]],pretty_row[[2]])
  coordB <- c(pretty_row[[3]],pretty_row[[4]])
  IDA <- pretty_row[[5]]
  IDB <- pretty_row[[6]]
  jour <- pretty_row[[7]]
  heure <- pretty_row[[8]]
  prix_parcours <- pretty_row[[9]]
  passagers <- pretty_row[[10]]
  
  #on calcule le pas vectoriel et le nb d'itération :
  distance <- distm(coordA,coordB)
  niteration = as.integer(distance / (largeur_cellule/5))
  pas = 1/niteration
  pas_vectoriel <- as.vector((coordB-coordA)*pas)
  
  infos <- 1:niteration
  etapes_coords <- map(infos, ~ coordA + pas_vectoriel*.x)
  etapes_Ids <- map(etapes_coords, ~ over_2(.x[[1]],.x[[2]],spatial_grid)[[1,1]])
  
  etapes_df <- do.call(rbind.data.frame, etapes_Ids)
  names(etapes_df)[1] <- "IDs"
  
  final_df <- etapes_df %>% mutate("Prix" = prix_parcours/niteration, "Passagers" = passagers, "Jour" = jour, "Heure" = heure)
  
  final_df <- final_df %>% 
    group_by(IDs, Passagers, Jour, Heure) %>% 
    summarise(nb = n(), Prix = sum(Prix)) %>% 
    ungroup()  


  return(final_df)
}


good_dataframe<-function(df,grid){
  #il reste encore un ou deux bugs
  #creates a whole dataframe with clean data
  
  map_df(df,~transformation(.x),grid)
  
  
}

good_dataframe(test,spatial_grid)
  
  
  


```


Pour la date : Create and format dates
To create a Date object from a simple character string in R, you can use the as.Date() function. The character string has to obey a format that can be defined using a set of symbols (the examples correspond to 13 January, 1982):

%Y: 4-digit year (1982)
%y: 2-digit year (82)
%m: 2-digit month (01)
%d: 2-digit day of the month (13)
%A: weekday (Wednesday)
%a: abbreviated weekday (Wed)
%B: month (January)
%b: abbreviated month (Jan)
The following R commands will all create the same Date object for the 13th day in January of 1982:

as.Date("1982-01-13")
as.Date("Jan-13-82", format = "%b-%d-%y")
as.Date("13 January, 1982", format = "%d %B, %Y")
Notice that the first line here did not need a format argument, because by default R matches your character string to the formats "%Y-%m-%d" or "%Y/%m/%d".

In addition to creating dates, you can also convert dates to character strings that use a different date notation. For this, you use the format() function. Try the following lines of code:

today <- Sys.Date()
format(Sys.Date(), format = "%d %B, %Y")
format(Sys.Date(), format = "Today is a %A!")


Pour l'Heure  : 
Create and format times
Similar to working with dates, you can use as.POSIXct() to convert from a character string to a POSIXct object, and format() to convert from a POSIXct object to a character string. Again, you have a wide variety of symbols:

%H: hours as a decimal number (00-23)
%I: hours as a decimal number (01-12)
%M: minutes as a decimal number
%S: seconds as a decimal number
%T: shorthand notation for the typical format %H:%M:%S
%p: AM/PM indicator
For a full list of conversion symbols, consult the strptime documentation in the console:

?strptime
Again,as.POSIXct() uses a default format to match character strings. In this case, it's %Y-%m-%d %H:%M:%S. In this exercise, abstraction is made of different time zones.
